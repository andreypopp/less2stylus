// Generated by CoffeeScript 1.6.3
var Parser, baseVisitor, crypto, defineVisitor, expressionVisitor, extend, fs, funcMap, genVar, isString, main, mixinMap, renderMixinArg, renderMixinParam, renderPrelude, renderTree, renderValue, toUnquoted, tree, treeVisitor, _ref, _ref1;

fs = require('fs');

crypto = require('crypto');

_ref = require('less'), Parser = _ref.Parser, tree = _ref.tree;

_ref1 = require('underscore'), extend = _ref1.extend, isString = _ref1.isString;

defineVisitor = function(base, props) {
  return extend(Object.create(base), props);
};

genVar = function(features) {
  return "var" + (crypto.createHash('md5').update(features).digest('hex'));
};

renderValue = function(node, options) {
  var impl, visitor;
  options = extend({}, options);
  if (isString(node)) {
    return node;
  }
  impl = Object.create(expressionVisitor);
  impl.options = options;
  visitor = new tree.visitor(impl);
  visitor.visit(node);
  if (impl.value) {
    return impl.value.trim();
  } else {
    return '';
  }
};

renderTree = function(node, indent) {
  var impl;
  if (indent == null) {
    indent = '';
  }
  impl = Object.create(treeVisitor);
  impl.indent = indent;
  return new tree.visitor(impl).visit(node);
};

renderMixinParam = function(node) {
  var param;
  param = node.name.slice(1);
  if (node.value) {
    param = "" + param + "=" + (renderValue(node.value));
  }
  return param;
};

renderMixinArg = function(node) {
  var param;
  param = renderValue(node.value);
  if (node.name) {
    param = "" + (node.name.slice(1)) + "=" + param;
  }
  return param;
};

renderPrelude = function() {
  return console.log("lesscss-percentage(n)\n  (n * 100)%".trim());
};

toUnquoted = function(value) {
  return value.replace(/@{/g, '"@{').replace(/}/g, '}"').split(/(@{)|}/).filter(function(v) {
    return v !== '@{' && v !== '}' && (v != null ? v.length : void 0) > 0;
  }).join(' + ');
};

funcMap = {
  '%': 's',
  'percentage': 'lesscss-percentage'
};

mixinMap = {
  translate: 'mixin-translate',
  scale: 'mixin-scale',
  rotate: 'mixin-rotate',
  skew: 'mixin-skew',
  translate3d: 'mixin-translate3d'
};

baseVisitor = {
  visitAlpha: function(node) {
    throw new Error('not implemented');
  },
  visitAnonymous: function(node) {
    throw new Error('not implemented');
  },
  visitAssigment: function(node) {
    throw new Error('not implemented');
  },
  visitAttribute: function(node) {
    throw new Error('not implemented');
  },
  visitCall: function(node) {
    throw new Error('not implemented');
  },
  visitColor: function(node) {
    throw new Error('not implemented');
  },
  visitComment: function(node) {
    throw new Error('not implemented');
  },
  visitCondition: function(node) {
    throw new Error('not implemented');
  },
  visitDimension: function(node) {
    throw new Error('not implemented');
  },
  visitDirective: function(node) {
    throw new Error('not implemented');
  },
  visitElement: function(node) {
    throw new Error('not implemented');
  },
  visitExpression: function(node) {
    throw new Error('not implemented');
  },
  visitExtend: function(node) {
    throw new Error('not implemented');
  },
  visitImport: function(node) {
    throw new Error('not implemented');
  },
  visitJavaScript: function(node) {
    throw new Error('not implemented');
  },
  visitKeyword: function(node) {
    throw new Error('not implemented');
  },
  visitMedia: function(node) {
    throw new Error('not implemented');
  },
  visitMixin: function(node) {
    throw new Error('not implemented');
  },
  visitMixinCall: function(node) {
    throw new Error('not implemented');
  },
  visitMixinDefinition: function(node) {
    throw new Error('not implemented');
  },
  visitNegative: function(node) {
    throw new Error('not implemented');
  },
  visitOperation: function(node) {
    throw new Error('not implemented');
  },
  visitParen: function(node) {
    throw new Error('not implemented');
  },
  visitQuoted: function(node) {
    throw new Error('not implemented');
  },
  visitRule: function(node, options) {
    throw new Error('not implemented');
  },
  visitRuleset: function(node, options) {
    throw new Error('not implemented');
  },
  visitSelector: function(node, options) {
    throw new Error('not implemented');
  },
  visitValue: function(node) {
    throw new Error('not implemented');
  },
  visitVariable: function(node) {
    throw new Error('not implemented');
  },
  visitURL: function(node) {
    throw new Error('not implemented');
  },
  visitUnicodeDescriptor: function(node) {
    throw new Error('not implemented');
  }
};

expressionVisitor = defineVisitor(baseVisitor, {
  acc: function(v) {
    if (!this.value) {
      this.value = '';
    }
    return this.value += ' ' + v;
  },
  visitAnonymous: function(node) {
    return this.acc(node.value);
  },
  visitDimension: function(node) {
    return this.acc("" + node.value + (node.unit.numerator.join('')));
  },
  visitVariable: function(node) {
    if (this.options.unquote) {
      return this.acc("@{" + (node.name.slice(1)) + "}");
    } else {
      return this.acc(node.name.slice(1));
    }
  },
  visitCall: function(node, options) {
    var args, name,
      _this = this;
    options.visitDeeper = false;
    args = node.args.map(function(e) {
      return renderValue(e, _this.options);
    }).join(', ');
    name = funcMap[node.name] || node.name;
    if (name === 's') {
      args = args.replace(/%d/g, '%s');
    }
    return this.acc("" + name + "(" + args + ")");
  },
  visitSelector: function(node, options) {
    var _this = this;
    options.visitDeeper = false;
    return this.acc(node.elements.map(function(e) {
      return "" + e.combinator.value + (renderValue(e, _this.options));
    }).join('').replace(/>/g, ' > ').replace(/\+/g, ' + '));
  },
  visitElement: function(node, options) {
    options.visitDeeper = false;
    return this.acc(renderValue(node.value, this.options));
  },
  visitAttribute: function(node, options) {
    var rendered;
    options.visitDeeper = false;
    rendered = node.key;
    if (node.op) {
      rendered += node.op + renderValue(node.value, this.options);
    }
    return this.acc("[" + rendered + "]");
  },
  visitKeyword: function(node) {
    return this.acc(node.value);
  },
  visitQuoted: function(node) {
    var value;
    if (node.escaped) {
      value = toUnquoted(node.value);
      return this.acc("unquote(" + node.quote + value + node.quote + ")");
    } else {
      return this.acc("" + node.quote + node.value + node.quote);
    }
  },
  visitParen: function(node, options) {
    options.visitDeeper = false;
    return this.acc("(" + (renderValue(node.value, this.options)) + ")");
  },
  visitRule: function(node, options) {
    options.visitDeeper = false;
    return this.acc("" + node.name + ": " + (renderValue(node.value, this.options)));
  },
  visitOperation: function(node, options) {
    var left, right, value, _ref2;
    options.visitDeeper = false;
    if (node.operands.length !== 2) {
      throw new Error('assertion');
    }
    _ref2 = node.operands, left = _ref2[0], right = _ref2[1];
    value = "" + (renderValue(left, this.options)) + " " + node.op + " " + (renderValue(right, this.options));
    value = "(" + value + ")";
    return this.acc(value);
  },
  visitValue: function(node, options) {
    var _this = this;
    options.visitDeeper = false;
    return this.acc(node.value.map(function(e) {
      return renderValue(e, _this.options);
    }).join(', '));
  },
  visitExpression: function(node, options) {
    var _this = this;
    options.visitDeeper = false;
    return this.acc(node.value.map(function(e) {
      return renderValue(e, _this.options);
    }).join(' '));
  },
  visitColor: function(node) {
    var c;
    if (node.rgb) {
      c = "rgb(" + (node.rgb.join(', '));
      if (node.alpha) {
        c += ", " + node.alpha;
      }
      c += ")";
      return this.acc(c);
    } else {
      throw new Error("unknow color " + node);
    }
  },
  visitNegative: function(node) {
    return this.acc("- " + (renderValue(node.value, this.options)));
  }
});

treeVisitor = defineVisitor(baseVisitor, {
  indent: '',
  increaseIndent: function() {
    return this.indent + '  ';
  },
  decreaseIndent: function() {
    return this.indent.slice(0, -2);
  },
  p: function(m, indent) {
    indent = indent || this.indent;
    return console.log("" + indent + (m.trim()));
  },
  isNamespaceDefinition: function(node) {
    var name;
    if (node.type !== 'Ruleset') {
      return false;
    }
    if (node.selectors.length !== 1) {
      return false;
    }
    name = renderValue(node.selectors[0]);
    if (name[0] !== '#') {
      return false;
    }
    if (!node.rules.every(function(rule) {
      return rule.type === 'MixinDefinition' || rule.type === 'Comment';
    })) {
      return false;
    }
    return name.slice(1);
  },
  isNamespaceCall: function(node) {},
  visitRuleset: function(node, options, directive) {
    var namespace, rule, _i, _j, _len, _len1, _ref2, _ref3, _results, _results1;
    if (directive == null) {
      directive = '';
    }
    if (!node.root) {
      namespace = this.isNamespaceDefinition(node);
      options.visitDeeper = false;
      if (namespace) {
        _ref2 = node.rules;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          rule = _ref2[_i];
          if (rule.type === 'MixinDefinition') {
            rule.name = "." + namespace + "-" + (rule.name.slice(1));
          }
          _results.push(renderTree(rule, this.indent));
        }
        return _results;
      } else {
        if (node.rules.length > 0) {
          this.p("" + directive + (node.selectors.map(renderValue).join(', ')));
          _ref3 = node.rules;
          _results1 = [];
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            rule = _ref3[_j];
            _results1.push(renderTree(rule, this.increaseIndent()));
          }
          return _results1;
        }
      }
    }
  },
  visitRulesetOut: function(node) {
    if (!node.root) {
      return this.decreaseIndent();
    }
  },
  visitRule: function(node, options) {
    var name;
    options.visitDeeper = false;
    name = node.name;
    if (name[0] === '@') {
      return this.p("" + (name.slice(1)) + " = " + (renderValue(node.value)));
    } else {
      return this.p("" + name + " " + (renderValue(node.value)) + node.important);
    }
  },
  visitComment: function(node) {
    if (!node.silent) {
      return this.p(node.value);
    }
  },
  visitMedia: function(node, options) {
    var features, mediaVar, rule, _i, _len, _ref2, _results;
    options.visitDeeper = false;
    features = renderValue(node.features, {
      unquote: true
    });
    if (/@{/.exec(features)) {
      mediaVar = genVar(features);
      this.p("" + mediaVar + " = \"" + (toUnquoted(features)) + "\"");
      this.p("@media " + mediaVar);
    } else {
      this.p("@media " + features);
    }
    _ref2 = node.ruleset.rules;
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      rule = _ref2[_i];
      _results.push(renderTree(rule, this.increaseIndent()));
    }
    return _results;
  },
  visitSelector: function(node, options) {
    options.visitDeeper = false;
    return this.p(node.elements.map(renderValue).join(''));
  },
  visitMixinDefinition: function(node, options) {
    var name, rule, _i, _len, _ref2;
    options.visitDeeper = false;
    name = node.name.slice(1);
    name = mixinMap[name] || name;
    this.p("" + name + "(" + (node.params.map(renderMixinParam).join(', ')) + ")");
    _ref2 = node.rules;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      rule = _ref2[_i];
      renderTree(rule, this.increaseIndent());
    }
    if (node.params.length === 0 || node.params.every(function(p) {
      return p.value != null;
    })) {
      this.p("." + name);
      return this.p("" + name + "()", this.increaseIndent());
    }
  },
  visitMixinCall: function(node, options) {
    var name, namespace, v;
    options.visitDeeper = false;
    if (node.selector.elements.length === 2 && node.selector.elements[0].value[0] === '#') {
      namespace = node.selector.elements[0].value.slice(1);
      node.selector.elements[0] = node.selector.elements[1];
      delete node.selector.elements[1];
      node.selector.elements[0].value = "" + namespace + "-" + (node.selector.elements[0].value.slice(1));
    }
    name = renderValue(node.selector).slice(1);
    name = mixinMap[name] || name;
    if (node["arguments"].length > 0) {
      v = "" + (renderValue(node.selector).slice(1));
      v += "(" + (node["arguments"].map(renderMixinArg).join(', ')) + ")";
    } else {
      v = "@extend ." + (renderValue(node.selector).slice(1));
    }
    return this.p(v);
  },
  visitImport: function(node, options) {
    options.visitDeeper = false;
    return this.p("@import " + (renderValue(node.path).replace(/\.less/, '.styl')));
  },
  visitDirective: function(node, options) {
    return this.visitRuleset(node.ruleset, options, node.name);
  }
});

main = function() {
  var filename, parser, str;
  filename = process.argv[2];
  parser = new Parser({
    filename: filename
  });
  str = fs.readFileSync(filename).toString();
  return parser.parse(str, function(err, node) {
    if (err) {
      throw err;
    }
    renderPrelude();
    return renderTree(node);
  });
};

module.exports = {
  main: main,
  treeVisitor: treeVisitor,
  expressionVisitor: expressionVisitor,
  baseVisitor: baseVisitor,
  renderValue: renderValue,
  renderTree: renderTree,
  renderPrelude: renderPrelude
};
